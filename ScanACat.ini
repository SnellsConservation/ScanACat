// libraries to include to use the MKR 1010, with mem shield et. al.
#include <SD.h>                  // for the sd card on the mem shield
#include <SPI.h>                 // serial peripheral interface for mem shield and rfid reader
#include <ArduinoLowPower.h>     // be able to use the low power options and wake on interupt to save power
#include <WiFiNINA.h>            // in this development we are using wifi to serve the data without having to remove the SD card more than necessary
#include <set>                   // implements a simple set datastructure, useful for the RFID Ids
#include <stdlib.h>              // standard c++ library general utilities
#include <RTClib.h>              // library supporting adafruit Real Time Clock.  The Adafruit PCF8523 only uses I2C 7-bit address 0x68
#include <Adafruit_SleepyDog.h>  //library to set up a watchdog (something that resets the processor if it isn't regularly updated)
#include <Wire.h>
// Using Arduino Low Power library and interrupts on the SAMD processor means the watchdog can only be active when not in low power mode
// So the watchdog is enabled only after an event occurs and is disabled before returning to low power mode.
//
//__________________________________________________________________________
// Configuration Information Definitions
// This allows for multiple configurations of the ScanACat


bool secondIR = true;             // if using a second IR break beam change to true
bool RGBLed = true;               // set to true if using an RGBLed for visual indicator
bool RTClock = true;              //set to true if using the real time clock add-on
bool Laser = false;                // set to true if using a laser light to encourage cat to enter
bool ResetRealTimeClock = false;  // a variable to reset the value of the real time clock to the compile time plus a few minutes
// Set pin number for SD card
const int chipSelect = 4;

// Set up flash chip pin if using (here just in case want to use in the future so commented out)
// const int FlashChipSelect = 5;  Currently not using flash on the mem shield, need to include a library for it if you want to use.


//Infrared Break Beam Sensor (receiver(s)).  Pin 4 for first one, if using a second use pin 5.
#define IRSENSORPIN 8
#define IR2SENSORPIN 1


//Laser Pin - this is an optional add-on of a red light emitting diode used as a way to attract some cats to enter the device
#define LaserPin A4

// RFID Reader pin to enable sleep or active mode
#define RFIDENABLEPIN 3

// A Button to trigger WiFi activation
#define buttonPin 7


// Define pins for RGB Led to signal users
#define redPin A1
#define greenPin A2
#define bluePin A5

// Define pins for RTC - this is the default pins for IC2 Communications on the Arduino MKR1010
// the PCF8523 is not very sophisitcated and needs to use the defaults and it's address can not be changed.
#define RTCPinSDA 11
#define RTCPinSCL 12


char daysOfTheWeek[7][12] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
char monthsOfTheYear[12][10] = {
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December"
};

// define RTC will need to change if using a different model breakout board
RTC_PCF8523 rtc;

//___________________________________________________________________________

//  Global Definitions for setting how long to do various things used in this way so field experience can be used to easily alter these durations if need be.
#define RFIDREADDURATION 60000  //  one minute spent reading tags when breakbeam is broken

#define WiFiReadDuration 600000  //   10 minutes for someone to connect (note as soon as they download the file they are disconnected)


#define ClientTimeout 300000  // if client doesn't request anything for 5 minutes close connection to save battery.

#define BarkTime 12000  // 12 seconds wait before watchdog restarts processor if watchdog not reset.

//______________________________________________________________________
// Global variable set up:
int lastYear, lastMonth, lastDay;  // global variables to check to see if the week has ticked over and it's time for a new log file.
bool SDCardProblems = false;       // a simple variable so that we can, if possible, send a message via wifi if the SD card is malfunctioning
bool Serial1Problems = false;      // a simple variable so we can indicate, if possible, that there are issues on the serial i/f to the RFID reader.
bool RTCProblems = false;          // a simple variable so we can indicate a problem with the Real Time Clock.
bool FlashProblems = false;        // a simple variable so we can indicate, if possible that there are issues with the flash on the mem card.
bool LedIsRed = false;             // a simple variable so we don't turn off the red led if we have a problem.
bool IsWiFi = false;               // a simple variable to say if wifi is there and working
bool RFIDProblems = false;         // a simple variable to say if there may be an issue with the RFID reader
unsigned long ReadPeriod = 0;      // a variable that keeps track of how many times the RFID reader has been turned on for times when there is
                                   // no real time clock.
DateTime IRInterruptTime;          // a global variable that keeps track of the time when the IR breakbeam was triggered when a Real Time Clock is used
//_______________________________________________________________________


// Tools
bool debug = false;          // Used to eliminate debug printing when done.  Also easy to then comment out all debugging code later.
bool TestWatchdog = false;  // set to true if you want the watchdog to reset the processor and make sure it's working


//__________________________________________________________________________________________________
//wifi configuration information,
char ssid[] = "ScanACatForAll";            // your network SSID (name) CHANGE THIS FOR YOUR AREA
char pass[] = "HelpTheWildlife";        // your network password (use for WPA, or use as key for WEP) you can choose your own password and set it here
int keyIndex = 0;                    // your network key Index number (needed only for WEP)
int Wifistatus = WL_IDLE_STATUS;     // WL_IDLE_STATUS is arduino constant part of wifi library
IPAddress local_IP(10, 10, 10, 10);  // IP Address, gateway and subnet for arduino webserver   Choose one easy for your volunteers to remember
// IANA has assigned certain IP addresses for private use you should pick your ip address within these ranges are 10.0.0.0 to 10.255.255.255; 172.16.0.0 to 172.31.255.255 or 192.168.0.0 to 192.168.255.255
IPAddress gateway(10, 10, 10, 1);  // the first three numbers should match the first three of your chosen IP address
IPAddress subnet(255, 255, 255, 0);
WiFiServer server(80);

//--------------------------------------------------------------------------------------------------------------------
//Declare files globally:  If there is a real time clock then files are stored on a weekly basis, and anytime someone fetches data the prior two weeks files are sent.
// if there is no real time clock, or something has gone wrong with it, one single file is kept (will get large).
File RFdataFile;
String CurrentWeekFileName;
String LastWeekFileName;
String DefaultFileName = "ids.txt";
File RootDir;

bool WeekChanged = false;

//-------------------------------------------------------------------------------------------------------------------

// Define message types we will receive from the RFID Reader
const char* MESSAGE_TYPES[] = { "CI", "FDX+", "FDX", "HDX" };
const int NUM_MESSAGE_TYPES = 4;

// Define message formats we will be getting from RFID reader
const char* MESSAGE_START[] = { "$T", "$R1", "$R2", "$R3" };
const char* MESSAGE_STOP = "#";
const int MESSAGE_LENGTH[] = { 10, 54, 20, 20 };


//-------------------------------------------------------------------------------------------------------------------
//Volatile variables are those that change based on interrupts
// simple flag for button pushes and breakbeam being triggered
volatile bool buttonPressed = false;
volatile bool irInterruptTriggered = false;



//  functions called

// Turn RGB LED light Red
void RedLight() {
  digitalWrite(redPin, HIGH);
  digitalWrite(greenPin, LOW);
  digitalWrite(bluePin, LOW);
  LedIsRed = true;
}

// Turn RGB LED Light Green ONLY if it is not red
void GreenLight() {
  if (!LedIsRed) {
    digitalWrite(redPin, LOW);
    digitalWrite(greenPin, HIGH);
    digitalWrite(bluePin, LOW);
  }
}
// Turn RGB LED light blue to indicate WIFI on as some errors can be sent to an end user over wifi
// Once client disconnects return the RGB LED to RED if it was RED.
void BlueLight() {
  digitalWrite(redPin, LOW);
  digitalWrite(greenPin, LOW);
  digitalWrite(bluePin, HIGH);
  if (LedIsRed) {
    RedLight();
  }
}
// Turn RGB LED light yellow (if it's not red) so people know it's trying to read RFID tags.
void YellowLight() {
  if (!LedIsRed) {
    digitalWrite(redPin, HIGH);
    digitalWrite(greenPin, HIGH);
    digitalWrite(bluePin, LOW);
  }
}

//Turn off the RGB LED if it isn't set to Red.
void NoLight() {
  if (!LedIsRed) {
    digitalWrite(redPin, LOW);
    digitalWrite(greenPin, LOW);
    digitalWrite(bluePin, LOW);
  }
}

void LaserLightOn() {
  if (Laser) {
    digitalWrite(LaserPin, HIGH);
  }
}

void LaserLightOff() {
  if (Laser) {
    digitalWrite(LaserPin, LOW);
  }
}
//These are the two ways of waking up the processor, the IR interrupt will trigger trying to read an RFID ID, the button will try to connect to something via WIFI.
void IRInterrupt() {
  irInterruptTriggered = true;
}

// Interrupt service routine for the button
void buttonInterrupt() {
  buttonPressed = true;  // Set flag to indicate button is pressed
}

void InitializeIRBreakBeam() {
  // SET UP IR BREAK BEAM
  pinMode(IRSENSORPIN, INPUT_PULLUP);  // turn on the resistor pullup for the IR sensor

  //Set IR beam interrupt to wake processor from low power mode
  LowPower.attachInterruptWakeup(digitalPinToInterrupt(IRSENSORPIN), IRInterrupt, FALLING);
}


void InitializeButton() {
  // Setup button pin (button for low power bluetooth connection)
  pinMode(buttonPin, INPUT_PULLUP);
  // Attach an interrupt to wake up from low power on button push
  LowPower.attachInterruptWakeup(digitalPinToInterrupt(buttonPin), buttonInterrupt, FALLING);
}

void InitializeRFID() {
  // Turn the RFID Reader/Antenna to low power.
  digitalWrite(RFIDENABLEPIN, LOW);

  // Get RFID serial1 bus going
  // Use Serial1 for communication with the RFID reader as this is the UART i/f
  Serial1.begin(115200);
}


void InitializeRTC() {
  DateTime CompileTime;
  Wire.begin();
  if (!rtc.begin()) {
    if (debug) {
      SerialUSB.println("Could not find RTC");
    }
    RTCProblems = true;
    RedLight();
    if (debug) { SerialUSB.println("Real Time Clock Issues"); }
    return;
  }
  rtc.start();

  // This code adds a delay of slightly more than 2 minutes and then sets the RTC if it is not initialized,
  // The RTC needs to run for at least 2 minutes (have battery and external power before you can set it)
  //  If you want to set a specific time (e.g. July 13 2024 at 12:55:00 you could substitute this with
  //   rtc.adjust(DateTime(2024, 7, 13, 12, 55, 00));
  if (!rtc.initialized() || rtc.lostPower() || ResetRealTimeClock) {
    if (debug) { SerialUSB.println("RTC not running"); }
    // Set RTC to the date and time this sketch was compiled
    CompileTime = DateTime(F(__DATE__), F(__TIME__));
    delay(140000);
    int year = CompileTime.year();
    int month = CompileTime.month();
    int day = CompileTime.day();
    int hour = CompileTime.hour();
    int minute = CompileTime.minute() + 4;
    int second = CompileTime.second();

    if (minute >= 60) {
      minute -= 60;
      hour++;
      if (hour >= 24) {
        hour -= 24;
        day++;
        // Handle day overflow depending on the month and leap year, etc.
        // This example does not handle all edge cases for month/year/day overflow
      }
    }

    rtc.adjust(DateTime(year, month, day, hour, minute, second));
    rtc.start();
  }

  if (!rtc.initialized()) {
    if (debug) { SerialUSB.println("RTC failed to initialize"); }
    RTCProblems = true;
    RedLight();
  }
}

void printWiFiStatus() {
  // print the SSID of the network you're attached to:
  if (debug) {
    SerialUSB.print("SSID: ");
    SerialUSB.println(WiFi.SSID());
  }
  // print your WiFi shield's IP address:
  IPAddress ip = WiFi.localIP();
  if (debug) {
    SerialUSB.print("IP Address: ");
    SerialUSB.println(ip);

    // print where to go in a browser:
    SerialUSB.print("To see this page in action, open a browser to http://");
    SerialUSB.println(ip);
    if (debug) {
      DateTime now = rtc.now();
      int week = getWeekNumber(now.year(), now.month(), now.day());
      SerialUSB.print("Filename current");
      SerialUSB.print(String(CurrentWeekFileName));
      SerialUSB.print(" ");
      SerialUSB.println(CurrentWeekFileName);
      SerialUSB.print(" last week file name");
      SerialUSB.print(String(LastWeekFileName));
      SerialUSB.print(" ");
      SerialUSB.println(LastWeekFileName);
    }
  }
}

bool InitializeWifi() {
  // Start Wifi
  // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    if (debug) { SerialUSB.println("Couldn't find WIF Module resetting and trying again."); }
    pinMode(NINA_RESETN, OUTPUT);
    digitalWrite(NINA_RESETN, LOW);
    delay(100);
    digitalWrite(NINA_RESETN, HIGH);
    delay(100);
  }
  if (WiFi.status() == WL_NO_MODULE) {

    if (RGBLed) {
      RedLight();  // Turn on REd light to indicate something is wrong
      if (debug) { SerialUSB.println("Wifi Module Not Detected"); }
    }
    return false;
  }

  String fv = WiFi.firmwareVersion();
  if (fv < WIFI_FIRMWARE_LATEST_VERSION) {
    if (debug) {
      SerialUSB.println("Please upgrade the firmware");
    }
  }

  // print the network name (SSID);
  if (debug) {
    SerialUSB.print("Creating access point named: ");
    SerialUSB.println(ssid);
  }
  // Create open network. Change this line if you want to create an WEP network:
  WiFi.config(local_IP, gateway, subnet);
  Wifistatus = WiFi.beginAP(ssid, pass);
  delay(1000);
  if (Wifistatus != WL_AP_LISTENING) {
    if (debug) { SerialUSB.println("Access Point Begin failed first time trying again."); }
    pinMode(NINA_RESETN, OUTPUT);
    digitalWrite(NINA_RESETN, LOW);
    delay(100);
    digitalWrite(NINA_RESETN, HIGH);
    delay(100);
    InitializeWifi();
    WiFi.config(local_IP, gateway, subnet);
    Wifistatus = WiFi.beginAP(ssid, pass);
  }
  if (Wifistatus != WL_AP_LISTENING) {
    // don't continue if this fails
    if (RGBLed) {
      if (debug) { SerialUSB.println("Wifi Access Point failed to start"); }
      RedLight();  // Turn on REd light to indicate something is wrong
    }
    return false;
  }


  // start the web server on port 80
  server.begin();

  // you're connected now, so print out the status
  printWiFiStatus();
  return true;
}


void InitializeMemShield() {
  // Initialize SD card
  if (!SD.begin(chipSelect)) {
    SDCardProblems = true;
    return;
  } else {
    RootDir = SD.open("/");

    RFdataFile = SD.open(DefaultFileName.c_str(), FILE_WRITE);
    if (!RFdataFile) {
      SDCardProblems = true;
      if (RGBLed) {
        if (debug) { SerialUSB.println("SD Card Issues"); }
        RedLight();  // Turn on REd light to indicate something is wrong
      }
      return;
    }
    RFdataFile.close();
    RootDir.close();
  }
}
// Function to calculate the day of the year from month and day
int calculateDayOfYear(int year, int month, int day) {
  const int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  int dayOfYear = 0;

  // Check if it's a leap year (for February 29)
  bool leapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);

  // Sum days of the months before the given month
  for (int i = 0; i < month - 1; i++) {
    dayOfYear += daysInMonth[i];
  }

  // Add the current day
  dayOfYear += day;

  // If it's a leap year and we're past February, add 1 extra day
  if (leapYear && month > 2) {
    dayOfYear += 1;
  }

  return dayOfYear;
}

int getWeekNumber(int year, int month, int day) {
  int dayOfYear = calculateDayOfYear(year, month, day);
  int week = (dayOfYear - 1) / 7 + 1;
  if (debug) {
    SerialUSB.print("day of year ");
    SerialUSB.println(dayOfYear);
    SerialUSB.print("week of year ");
    SerialUSB.println(week);
  }
  return week;
}

void SetFileNames(int year, int month, int day) {
  int currentWeek = getWeekNumber(year, month, day);
  // build currentfilename
  CurrentWeekFileName = "y" + String(year) + "w" + String(currentWeek) + ".txt";
  if (debug) {
    SerialUSB.print("Current File Name ");
    SerialUSB.println(CurrentWeekFileName);
  }

  // Calculate previous week, handling rollover to the previous year
  int previousWeek = currentWeek - 1;
  int previousYear = year;

  if (previousWeek < 1) {
    previousWeek = 52;  // Assuming the previous year had 52 weeks (adjust for leap years if needed)
    previousYear = year - 1;
  }

  LastWeekFileName = "y" + String(previousYear) + "w" + String(previousWeek) + ".txt";
  if (debug) {
    SerialUSB.print("Last week File Name ");
    SerialUSB.println(LastWeekFileName);
    SerialUSB.println("Leaving set file names");
  }
}


// Set the global variable values for the current and last week file names.
void handleRTCFileInitialization() {
  DateTime now = rtc.now();
  File currentWeekFile;
  File lastWeekFile;
  SetFileNames(now.year(), now.month(), now.day());
  // Check if last week's file exists and create it if not
  SerialUSB.println("about to see if last weeks file exists");
  if (!SD.exists(LastWeekFileName.c_str())) {
    if (debug) { SerialUSB.println("trying to create last weeks file"); }
    lastWeekFile = SD.open(LastWeekFileName.c_str(), FILE_WRITE);
    if (!lastWeekFile) {
      if (debug) {
        SerialUSB.println("Error opening last week file.");
      }
      SDCardProblems = true;
      RedLight();
      lastWeekFile.close();
      return;
    }
    SerialUSB.println("adding read period 0 to last week file");
    lastWeekFile.println("*&*Read Period: 0");
    lastWeekFile.close();
  }

  // See if this weeks file already exists, and create it if not  the read period gets reset to 0 each week.
  if (!SD.exists(CurrentWeekFileName.c_str())) {
    currentWeekFile = SD.open(CurrentWeekFileName.c_str(), FILE_WRITE);
    if (!currentWeekFile) {
      if (debug) {
        SerialUSB.println("Error opening current week file.");
      }
      SDCardProblems = true;
      RedLight();
      currentWeekFile.close();
      return;
    }
    SerialUSB.println("adding read period 0 to current week file");
    currentWeekFile.println("*&*Read Period: 0");
    currentWeekFile.close();
  }
}



void WakeUpWifiOnly() {
  InitializeMemShield();  // Memshield card will need to be woken again
  IsWiFi = InitializeWifi();
}

void wakeupRFIDOnly() {
  InitializeRFID();       // if the interrupts work independently for low power wakeup we can separate this into wakeup the Bluetooth and wake up the RFID to save power.
  InitializeMemShield();  // SD card will need to be initialized again whether waking up due to breakbeam or button push
  if (debug) { SerialUSB.println("Setting RFIDENABLE to HIGH"); }
  digitalWrite(RFIDENABLEPIN, HIGH);  // turn RFID reader onto high power mode
}

bool IsABreakBeamBroken() {
  bool beambroken = false;
  if (digitalRead(IRSENSORPIN) == LOW) {
    // if (debug) { SerialUSB.println("First Breakbeam broken"); }
    beambroken = true;
  }
  if (secondIR) {
    if (digitalRead(IR2SENSORPIN) == LOW){
      //  if (debug) { SerialUSB.println("Second Breakbeam broken"); }
        beambroken = true;
      }
  }
  return beambroken;
}

String hexToDecimalConcatenate(const String& countryCodeHex, const String& idHex) {
  // Convert hex strings to decimal values
  unsigned long countryCodeDecimal = strtoul(countryCodeHex.c_str(), nullptr, 16);
  unsigned long long idDecimal = strtoull(idHex.c_str(), nullptr, 16);

  // Create String objects to hold padded decimal values
  String paddedCountryCode;
  String paddedId;

  // Pad countryCode with leading zeros if needed
  while (countryCodeDecimal > 0) {
    paddedCountryCode = String(countryCodeDecimal % 10) + paddedCountryCode;
    countryCodeDecimal /= 10;
  }
  while (paddedCountryCode.length() < 3) {
    paddedCountryCode = "0" + paddedCountryCode;
  }

  // Pad ID with leading zeros if needed
  while (idDecimal > 0) {
    paddedId = String((unsigned long)(idDecimal % 10)) + paddedId;
    idDecimal /= 10;
  }
  while (paddedId.length() < 12) {
    paddedId = "0" + paddedId;
  }

  // Concatenate countryCode and ID with leading zeros
  String result = "$C" + paddedCountryCode + paddedId + "#";

  // Return the concatenated string
  return result;
}

int calculateChecksum(const String& ID) {
  int checksum = 0;

  // XOR all characters in label and ID as this prescribed checksum method for this RFID reader

  for (char c : ID) {
    checksum ^= c;
  }

  return checksum;
}

void ControlLaserLight(bool& LaserState, unsigned long& PreviousLaserChange) {
  unsigned long currenttimeis = millis();
  long LaserOnDuration = random(500, 3000);
  long LaserOffDuration = random(800, 3000);
  if (LaserState == HIGH) {
    if (currenttimeis - PreviousLaserChange >= LaserOnDuration) {
      LaserState = LOW;
      LaserLightOff();
      PreviousLaserChange = currenttimeis;
    }

  } else {
    if (currenttimeis - PreviousLaserChange >= LaserOffDuration) {
      LaserState = HIGH;
      LaserLightOn();
      PreviousLaserChange = currenttimeis;
    }
  }
}

void readRFIDDevice() {
  unsigned long startTime = millis();  // Record the start time of RFID reading
  String uniqueIDs;                    // Store unique IDs
  String ID;                           //variable for reading the ID
  String IDminusCS;                    // the ID minus the checksum and #
  String IDCountryCode;                // The country code from the ID
  String IDOnly;                       // the digits in the ID only
  String ConvertedID;

  bool LaserState = LOW;
  bool Got_Antenna = false;  // if we don't receive any antenna data there is something wrong and we need to flag it as chips won't be read
  unsigned long PreviousLaserChange = 0;
  int TimesLooped = 0;
  bool matched = false;
  unsigned long MaxTimeToRead = 1000;
  unsigned long readTime = 0;


  //sleep and/or interrupts interfere with I2C and RTC so resuming these
  if (RTClock && !RTCProblems) {
    Wire.begin();
    rtc.start();
  }

  // The RFID reader sends a starting bit of "$", followed by a label, digit ID, and 2 bit checksum, and a final character "#".
  // The checksum is an xor of the label and 15 digit ID.   This reader sends twice with each read achieved e.g. $L<ID><CS>#$L<ID><CS>#
  // I have found that we need to write to the RFID Reader that we want to read, so this sends the required command to read
  if (!Serial1.write("$R#")) {
    if (debug) {
      SerialUSB.println("Failed to write to serial 1");  //debug code
    }
    Serial1Problems = true;
    if (RGBLed) {
      RedLight();  // Turn on the LED and make it RED so people know something is wrong
    }
    return;
  }

  // Turn on the antenna for reading of chips
  if (!Serial1.write("$C+A+#")) {
    if (debug) {
      SerialUSB.println("Failed to write to serial 1");  //debug code
    }
    Serial1Problems = true;  // may be able to use this to send something to a WIFI device to indicated there has been a failure re serial 1 i/f to rfid reader
    if (RGBLed) {
      RedLight();  // Turn on the LED and make it RED so people know something is wrong
    }
    return;  // Exit the function if unable to write to the serial i/f for RFID reader
  }
  if (RGBLed) {
    YellowLight();  // Turn light Yellow to indicate RFID reader is on
  }
  ID = "";

  // For the designated amount of time have the RFID reader in high power and read any RFID chips in range, or if the breakbeam remains broken
  while (millis() - startTime < RFIDREADDURATION || IsABreakBeamBroken()) {
    Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor
    matched = false;
    
    // While there are any characters available on the serial interface, read the character
    readTime = millis();
    while (millis() - readTime <= MaxTimeToRead) {
      Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

      // if using a laser or light to attract something into the device, then turn the laser on and off based on predefined timing
      if (Laser) {
        ControlLaserLight(LaserState, PreviousLaserChange);
      }

      if (Serial1.available() > 0) {

        // Read from the serial uart interface
        char onebit = Serial1.read();

        // If the character is a "$" it is possibly the first character of an ID string for the RFID reader chosen for this project
        if (onebit == '$') {
          ID = "$";  // found the start character so clear the ID just in case there was garbage on the interface and set the first character

        } else {
          //Append the bit to the ID string until it is complete
          ID += onebit;
          if (onebit == '#') {  // a # is the last character of an ID for this reader, if you find it break out of this loop and verify it is a good ID
            break;
          }
        }
      }
    }
    if (ID.length() > 0) {

      // Check that we received a valid message
      // for this RFID reader there are 4 different types of valid messages, previousy defined.  This reader will also read pipe tags, and send antenna
      // tuning data.   All data that is not an animal tag at 134.2 kHz is thrown away.  If you wish to see it turn on debug mode and add another line to show data
      // that doesn't match.
      // I throw out the antenna tunning data
      // if you want antenna tuning data change 1 to 0 in the for loop.
      for (int i = 1; i < 4; i++) {
        if (ID.startsWith(MESSAGE_START[i]) && ID.length() == MESSAGE_LENGTH[i]) {
          matched = true;
          if (debug) {
            SerialUSB.print("read this in matched: ");
            SerialUSB.println(ID);
          }
          // Code to execute if ID matches the start and length
          break;  // Exit the loop if a match is found
        }
      }

      if (!matched) {
        if (ID.startsWith("$J") || ID.startsWith("$T")) {
          if (ID.startsWith("$T")) {  // we need to track if we got antenna data, as if the RFID reader fails sometimes the only way we know this is the lack of antenna data
            Got_Antenna = true;
          }
          ID = "";
          continue;
        } else {
          if (debug) { SerialUSB.println(ID); }
          // Discard this incomplete or invalid message and continue reading
          ID = "";
          continue;
        }
      }
    }
    if (ID.length() == 0) {
      continue;
    }
    // The string was the correct length, next step is to
    // Extract the last three characters (which are a checksum plus end character for this Reader) from the ID
    String checksumString = ID.substring(ID.length() - 3);
    checksumString = checksumString.substring(0, checksumString.length() - 1);  // remove the last character from the string so it has only the checksum.
    int expectedChecksum = strtol(checksumString.c_str(), NULL, 16);            // Convert hexadecimal checksum to integer

    // Remove the first character the $ from the ID
    IDminusCS = ID.substring(1);
    // Remove the last three characters (checksum and '#') from IDminusCS
    IDminusCS = IDminusCS.substring(0, IDminusCS.length() - 3);

    Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor


    // Calculate checksum of the ID read
    int checksum = calculateChecksum(String(IDminusCS));

    Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

    // if the checksum of the ID is not the expected checksum discard it and try again; NOTE I'm assuming all message types use the same checksum algorithm
    if (checksum != expectedChecksum) {
      if (debug) {
        SerialUSB.print("bad checksum: ");
        SerialUSB.println("ID");
      }
      ID = "";   // discard the bad ID
      continue;  // See if a valid ID is available
    }



    // If this is antenna tuning data, only keep it if debugging and keep a limited number (change TimesLooped > "n" to be the number wanted minus 1, e.g. 1 gets 2 reads).
    // commented out only put back if wanting to debug antenna tuning
    /*
    if (ID.startsWith(MESSAGE_START[0]) && ID.length() == MESSAGE_LENGTH[0]) {
      if (debug) {
        if (TimesLooped > 1) {
          ID = "";
          continue;
        } else {
          TimesLooped++;
        }
      } else {
        ID = "";
        continue;
      }
    }

   */

    // If this isn't antenna data convert the ID from hex to Dec
    if (!(ID.startsWith(MESSAGE_START[0]) && ID.length() == MESSAGE_LENGTH[0])) {
      String CountryCodeHex = IDminusCS.substring(3, 6);
      String IDHex = IDminusCS.substring(6, 16);
      ConvertedID = hexToDecimalConcatenate(CountryCodeHex, IDHex);
      if (debug) {
        SerialUSB.print("ID read");
        SerialUSB.println(ConvertedID);
      }
    } else if (debug) {
      SerialUSB.print("READ THIS:");
      SerialUSB.println(ID);
    }
    // Check if ID is unique
    if (uniqueIDs.indexOf(ID) == -1) {
      // Store the unique ID
      uniqueIDs += ID + "\n";
      uniqueIDs += ConvertedID + "\n";
    }
    ID = "";
   
  }
  Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

  // turn off the antenna
  if (!Serial1.write("$C+B+#")) {
    if (debug) {
      SerialUSB.println("Failed to write to serial 1");  //debug code
    }
    if (RGBLed) {
      RedLight();  // Turn on the LED and make it RED so people know something is wrong
    }
    if (Laser) {
      LaserLightOff();  // turn off the Laser or Light before leaving the function
    }
    Serial1Problems = true;  // may be able to use this to send something to a WiFi device to indicated there has been a failure re serial 1 i/f to rfid reader
    return;                  // Exit the function if unable to write to the serial i/f for RFID reader
  }


  Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor
  InitializeMemShield();

  if (SDCardProblems) {
    RedLight();
    if (debug) {
      SerialUSB.println("SDCardProblems");
    }
    if (Laser) { LaserLightOff(); }  // turn off the Laser or Light before leaving the function
    return;
  }

  if (RTCProblems || !RTClock) {
    RFdataFile = SD.open(DefaultFileName.c_str(), FILE_WRITE);
  } else {
    RFdataFile = SD.open(CurrentWeekFileName.c_str(), FILE_WRITE);
  }

  if (!RFdataFile) {
    if (debug) {
      SerialUSB.println("Error opening file for writing");  //debug
    }
    SDCardProblems = true;
    if (RGBLed) {
      RedLight();  // Turn on the LED and make it RED so people know something is wrong
    }
    if (Laser) {
      LaserLightOff();  // turn off the Laser or Light before leaving the function
    }
    return;
  }
  if (!uniqueIDs.isEmpty()) {
    // Write unique IDs to SD card
    // Check if uniqueIDs is not empty before writing to the file

    RFdataFile.print("*&*Read Period: ");
    RFdataFile.println(ReadPeriod);
    RFdataFile.println(uniqueIDs);  //Write the unique IDs collected to the SD card

    if (RTClock && !RTCProblems) {
      if (debug) { SerialUSB.println("writing data and time to SD card"); }
      RFdataFile.print("Read Period Began at: ");
      RFdataFile.print(daysOfTheWeek[IRInterruptTime.dayOfTheWeek()]);
      RFdataFile.print(" ");
      RFdataFile.print(IRInterruptTime.day(), DEC);
      RFdataFile.print(" ");
      RFdataFile.print(monthsOfTheYear[(IRInterruptTime.month() - 1)]);
      RFdataFile.print(" ");
      RFdataFile.print(IRInterruptTime.year(), DEC);
      RFdataFile.print(" ");
      RFdataFile.print(IRInterruptTime.hour(), DEC);
      RFdataFile.print(":");
      RFdataFile.println(IRInterruptTime.minute(), DEC);
      RFdataFile.print("*&*Read Period: ");
      RFdataFile.println(ReadPeriod);
    }

  } else {
    RFdataFile.print("*&*Read Period: ");
    RFdataFile.println(ReadPeriod);
    RFdataFile.println("No IDs read");

    if (RTClock && !RTCProblems) {
      if (debug) { SerialUSB.println("writing data and time to SD card"); }
      RFdataFile.print("Read Period Began at: ");
      RFdataFile.print(daysOfTheWeek[IRInterruptTime.dayOfTheWeek()]);
      RFdataFile.print(" ");
      RFdataFile.print(IRInterruptTime.day(), DEC);
      RFdataFile.print(" ");
      RFdataFile.print(monthsOfTheYear[(IRInterruptTime.month() - 1)]);
      RFdataFile.print(" ");
      RFdataFile.print(IRInterruptTime.year(), DEC);
      RFdataFile.print(" ");
      RFdataFile.print(IRInterruptTime.hour(), DEC);
      RFdataFile.print(":");
      RFdataFile.println(IRInterruptTime.minute(), DEC);
      RFdataFile.print("*&*Read Period: ");
      RFdataFile.println(ReadPeriod);
    }
  }
  Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

  // be tidy and close the file
  RFdataFile.close();

  if (!Got_Antenna) {
    RedLight();
    RFIDProblems = true;
    if (debug) { SerialUSB.println("no antenna data received"); }
  }
  if (RGBLed) {
    GreenLight();  // Turn LED back to green if it's not red (visual indicator processor is awake but not doing much)
  }
  // Put the RFIDReader back in low power mode.
  if (debug) { SerialUSB.println("RFID READER ENABLE LOW"); }
  digitalWrite(RFIDENABLEPIN, LOW);
  digitalWrite(LED_BUILTIN, LOW);
  if (Laser) {
    LaserLightOff();
  }
}
//Find size of Id file
unsigned long GetCharactersInFile() {
  unsigned long characterCount = 0;
  String line = "";
  File PriorWeek;
  bool TwoFiles = false;

  if (RTCProblems || !RTClock) {
    RFdataFile = SD.open(DefaultFileName.c_str(), FILE_WRITE);
  } else {
    RFdataFile = SD.open(CurrentWeekFileName.c_str(), FILE_WRITE);
    PriorWeek = SD.open(LastWeekFileName.c_str(), FILE_WRITE);
    TwoFiles = true;
  }

  if (RFdataFile) {
    while (RFdataFile.available()) {
      Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor
      line = RFdataFile.readStringUntil('\n');
      line.trim();
      characterCount += line.length() + 1;
    }
  }

  if (TwoFiles) {
    while (PriorWeek.available()) {
      Watchdog.reset();
      line = PriorWeek.readStringUntil('\n');
      line.trim();
      characterCount += line.length() + 1;
    }
  }


  if (debug) {
    SerialUSB.print("total characters found: ");
    SerialUSB.println(characterCount);
    SerialUSB.print("File Size: ");
    if (!TwoFiles) {
      SerialUSB.println(RFdataFile.size());
    } else {
      SerialUSB.println((RFdataFile.size() + PriorWeek.size()));
    }
  }
  RFdataFile.close();
  if (TwoFiles) {
    PriorWeek.close();
  }
  return characterCount;
}

// Function to extract and print data associated with the specified range of read periods in reverse order
// while it would be simpler to serve it in order this allows people to see the most recent data first
// it could be more efficient by reading in buffered chunks but doing so would make the code harder for beginners to understand so currently leaving it this way
void extractDataForClient(WiFiClient client) {
  DateTime CurrentTime;
  String line;
  File PriorWeekFile;
  String additionalData;
  unsigned long contentLength;
  unsigned long actualSentLength;
  unsigned long charactersInFile = 0;
  unsigned long sizeofFiles = 0;
  line = "";
  additionalData = "";
  contentLength = 0;
  actualSentLength = 0;

  bool TwoFiles;

  //  The below is data that gets sent to the wifi client, in addition to the log data from the SD Card
  //  In the event the log data can't be retrieved from the SD card, the client will receive the error data.
  if (SDCardProblems) {
    additionalData += "There is a problem with the SD Card, please reformat or replace.\n";
  }
  if (Serial1Problems) {
    additionalData += "There appears to be a problem connecting to or with the RFID reader board, please diagnose.\n";
  }
  if (RTCProblems) {
    additionalData += "There is an issue with the Real Time Clock, please diagnose.\n";
  }
  if (RFIDProblems) {
    additionalData += "There may be an issue with the RFID reader, please diagnose. \n";
  }
  if (RTClock && !RTCProblems) {
    CurrentTime = rtc.now();
    additionalData += "The current date and time is: ";
    additionalData += daysOfTheWeek[CurrentTime.dayOfTheWeek()];
    additionalData += (" ");
    additionalData += CurrentTime.day();
    additionalData += (" ");
    additionalData += monthsOfTheYear[(CurrentTime.month() - 1)];
    additionalData += (" ");
    additionalData += CurrentTime.year();
    additionalData += " ";
    additionalData += CurrentTime.hour();
    additionalData += ":";
    additionalData += CurrentTime.minute();
    additionalData += " ";
    additionalData += ("\n");
  }

  additionalData += ("Between the $C and the # are the digits of the ID that will be in the animal registry database, $R<n>#is the hexidecimal header, ID and checksum received from the RFID reader for debugging/testing purposes. \n");
  additionalData += ("\n");

  // the size of the file(s) doesn't always match the number of characters, presumably due to some encoding
  // so in order to have the content size correct we need to find the number of characters in the file(s)
  charactersInFile = GetCharactersInFile();

  if (RTCProblems || !RTClock) {
    RFdataFile = SD.open(DefaultFileName.c_str(), FILE_READ);
    sizeofFiles = RFdataFile.size();
    TwoFiles = false;
  } else {
    RFdataFile = SD.open(CurrentWeekFileName.c_str(), FILE_READ);
    PriorWeekFile = SD.open(LastWeekFileName.c_str(), FILE_READ);
    sizeofFiles = RFdataFile.size() + PriorWeekFile.size();
    TwoFiles = true;
  }


  if (!RFdataFile) {
    RedLight();
    SDCardProblems = true;
    if (debug) { SerialUSB.println("SDCard Issues"); }
  }

  if (SDCardProblems) {

    // Calculate total content length
    contentLength = additionalData.length();

    // File not found, send an error file to the client (404 wasn't working reliably)
    client.println("HTTP/1.1 200 OK");
    client.println("Content-Disposition: attachment; filename=ScanACatErrors.txt");
    client.println("Content-Type: text/plain");
    client.print("Content-Length: ");
    client.println(contentLength);
    client.println("Connection: close");
    client.println("Cache-Control: no-cache");
    client.println("\r\n");
    client.flush();

    client.print(additionalData);
    client.flush();

    if (RGBLed) {
      RedLight();  // Turn on the LED and make it RED so people know something is wrong
    }
    if (debug) {
      SerialUSB.print("content length: ");
      SerialUSB.println(contentLength);
    }
    return;
  }

  // get the size of the defaul file from the sd card ... only if not using a real time clock or if problems with rtc as there is a limit to how big it can get
  // although the serving of the file will get so slow someone is likely to reformat the SD card before it hits it's limit.
  if (!TwoFiles) {
    additionalData += "The data file is currently: " + String(RFdataFile.size()) + " bytes, please compare to size allowed and replace or erase card if necessary\n";
  }

  if (sizeofFiles > charactersInFile) {
    // Calculate total content length
    contentLength = sizeofFiles + additionalData.length();
    if (debug) { SerialUSB.println("Using File size."); }
  } else {
    contentLength = charactersInFile + additionalData.length();
    if (debug) { SerialUSB.println("Using Characters In File"); }
  }
  if (debug) {
    SerialUSB.print("Additional Data length plus File length is: ");
    SerialUSB.println(contentLength);
  }

  // Send HTTP response headers
  client.println("HTTP/1.1 200 OK");
  client.println("Content-Disposition: attachment; filename=ScanACatIDs.txt");
  client.println("Content-Type: text/plain");
  client.print("Content-Length: ");
  client.println(contentLength);
  client.println("Connection: close");
  client.println("Cache-Control: no-cache");
  client.println("\r\n");
  client.flush();

  client.print(additionalData);
  client.flush();


  // end of line and carriage returns can causes an issue with the content length calculation so keep track of what we have sent
  actualSentLength = additionalData.length();

  while (RFdataFile.available()) {
    Watchdog.reset();
    line = RFdataFile.readStringUntil('\n');
    line.trim();
    line += '\n';
    actualSentLength += line.length();
    client.print(line);
  }
  if (TwoFiles) {
    while (PriorWeekFile.available()) {
      Watchdog.reset();
      line = PriorWeekFile.readStringUntil('\n');
      line.trim();
      line += '\n';
      actualSentLength += line.length();
      client.print(line);
    }
  }

  client.flush();


  if (debug) {
    SerialUSB.print("Content Length: ");
    SerialUSB.println(contentLength);
    SerialUSB.print(" Actual Sent Length: ");
    SerialUSB.println(actualSentLength);
  }

  if (actualSentLength < contentLength) {
    unsigned long paddingLength = contentLength - actualSentLength;
    if (debug) {
      SerialUSB.print(" padding length: ");
      SerialUSB.println(paddingLength);
    }
    for (unsigned long i = 0; i < paddingLength; i++) {
      client.print(".");
    }
    actualSentLength += paddingLength;
  }
  if (debug) {
    SerialUSB.print("Content Length: ");
    SerialUSB.println(contentLength);
    SerialUSB.print(" Padded Sent Length: ");
    SerialUSB.println(actualSentLength);
  }

  RFdataFile.close();
  if (TwoFiles) {
    PriorWeekFile.close();
  }
}

void HandleWifiConnection() {
  unsigned long StartPeriod;
  // Only check for wifi client if the button is pushed
  if (buttonPressed) {
    unsigned long WifiStartTime = millis();  // Record the start time of looking for WiFi connection
    if (RGBLed) {
      BlueLight();  // Turn on the LED and make it Blue so people know wifi is available
    }
    while ((millis() - WifiStartTime) < WiFiReadDuration) {
      Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

      // compare the previous status to the current status
      if (Wifistatus != WiFi.status()) {
        // it has changed, update the variable
        Wifistatus = WiFi.status();

        if (Wifistatus == WL_AP_CONNECTED) {
          // a device has connected to the AP
          if (debug) {
            SerialUSB.println("Device connected to AP");
          }
        } else {
          if (debug) {
            // a device has disconnected from the AP, and we are back in listening mode
            SerialUSB.println("Device disconnected from AP");
          }
        }
      }

      WiFiClient client = server.available();  // listen for incoming clients
      if (client) {

        unsigned long lastRequestTime = millis();

        // bool isFirstRequest = true;


        while (client.connected()) {
          Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

          if (client.available()) {
            // Read the request from the client
            String request = client.readStringUntil('\r');
            client.readStringUntil('\n');
            client.flush();
            // Handle preflight OPTIONS request
            if (request.indexOf("OPTIONS") >= 0) {
              client.println("HTTP/1.1 204 No Content");
              client.println("Access-Control-Allow-Origin: *");
              client.println("Access-Control-Allow-Methods: POST, GET, OPTIONS");
              client.println("Access-Control-Allow-Headers: Content-Type");
              client.println("Connection: keep-alive");
              client.println("\r\n");
              client.flush();
              continue;  // Continue to keep the connection open
            }


            extractDataForClient(client);

            client.flush();
            client.stop();
            if (debug) { SerialUSB.println("flushed and stopped client after serving data."); }
            if (RGBLed) {
              NoLight();  // Turn off the LED (or leave it RED if it was RED) as will turn off access point after single serve of data
            }
            return;
          }

          // Check for timeout
          if (millis() - lastRequestTime > ClientTimeout) {
            // Close the connection if there's been no activity for too long
            if (debug) { SerialUSB.println("Stopping client as timeout reached."); }
            client.stop();
            if (RGBLed) {
              if (LedIsRed) {
                RedLight();
              } else {

                NoLight();  // Turn off the LED as will turn off access point after single serve of data}
              }
            }

            break;
          }
        }
        if (debug) {
          SerialUSB.println("Client disconnected");
        }
      }
    }  // end read time check
  }    // end if button pushed
}  //end function handlewifi







// Function to extract the last written Read Period count from the data file(s) on the sd card, or create the file if it does not exist

long extractLastReadPeriod() {
  String line = "";
  bool FoundBBCount = false;
  long lastReadPeriod = 0;
  // if there is an RTC clock make sure there are files for both this week and the prior week and create them if not.
  // if there is not an RTC clock, then make sure there is a default file and create it if not.
  if (RTClock && !RTCProblems) {
    RFdataFile = SD.open(CurrentWeekFileName.c_str(), FILE_WRITE);
  } else {
    if (!SD.exists(DefaultFileName.c_str())) {
      RFdataFile = SD.open(DefaultFileName.c_str(), FILE_WRITE);
      RFdataFile.println("*&*Read Period: 0");
      return 0;
    }
    RFdataFile = SD.open(DefaultFileName.c_str(), FILE_READ);
  }

  if (!RFdataFile) {
    SerialUSB.println("Error opening data file");
    if (RGBLed) {
      RedLight();  // Turn on REd light to indicate something is wrong
      if (debug) { SerialUSB.println("SD Card Issues"); }
    }
    SDCardProblems = true;
    return 0;
  }



  // Start from the end of the file
  unsigned long currentPos = RFdataFile.size();

  // We'll iterate backward from the end of the file
  // until we find the last Read Period
  while (currentPos > 0) {
    Watchdog.reset();  // Reset the watchdog so it doesn't restart the processor

    // Move the file pointer to the current position
    RFdataFile.seek(currentPos - 1);
    //Watchdog.reset(); // Reset the watchdog so it doesn't restart the processor

    char c = RFdataFile.read();

    if (c == '\n' || c == '\r') {
      // Move the file pointer one position forward
      RFdataFile.seek(currentPos);

      // Read the line at the current position
      line = RFdataFile.readStringUntil('\n');

      // Print the line to USB for debug
      if (debug) {
        SerialUSB.print("Line Read:");
        SerialUSB.println(line);
      }


      // Check if the line starts with "*&*Read Period:"
      if (line.startsWith("*&*Read Period:")) {
        // Extract the Read Period number and update the lastReadPeriod
        lastReadPeriod = line.substring(16).toInt();
        RFdataFile.close();
        if (debug) {
          SerialUSB.print("returning with Read Period Count of ");
          SerialUSB.println(lastReadPeriod);
        }
        return lastReadPeriod;
      }
      currentPos--;
    } else {
      currentPos--;
    }
  }

  // No "*&*Read Period:" line found, return 0
  RFdataFile.close();
  return 0;
}







// This is a bit of test code to make sure the watchdog is working
void DoesTheDogHunt() {
  //this just checks that the processor gets reset of the watchdog is enabled.
  if (debug) { SerialUSB.println("About to see if the watchdog resets the processor"); }
  delay(20000);
  SerialUSB.println("shouldn't see this line");
}


//--------------------------------------------------------------------------------------------------------------------------
// This is the setup function, I start with initiallizing all components,
// but some things will have to be initialized again when the processor is woken from a sleep
// Hence, setup is broken into various components being initialized.
// The initial set up is run only once, before the main loop is entered.
void setup() {
  DateTime CompileTime;
  SerialUSB.begin(57600);  // start the serial bus on the MKR1010
  delay(1000);             // need short delay for things to come up properly

  // Set up RGB LED if in use
  if (RGBLed) {
    //Defining the pins as OUTPUT
    pinMode(redPin, OUTPUT);
    digitalWrite(redPin, LOW);
    pinMode(greenPin, OUTPUT);
    digitalWrite(greenPin, LOW);
    pinMode(bluePin, OUTPUT);
    digitalWrite(bluePin, LOW);
    GreenLight();  // temporarily turn on the green LED for status purposes
  }
  if (Laser) {
    pinMode(LaserPin, OUTPUT);
    digitalWrite(LaserPin, LOW);
  }
  // SET UP IR BREAK BEAM(s)
  // initialize the sensor pin as an input with resistor pull up:
  pinMode(IRSENSORPIN, INPUT_PULLUP);  // turn on the resistor pullup for the IR sensor
  //Set IR beam interrupt to wake processor from low power mode
  LowPower.attachInterruptWakeup(digitalPinToInterrupt(IRSENSORPIN), IRInterrupt, FALLING);

  if (secondIR) {
    pinMode(IR2SENSORPIN, INPUT_PULLUP);
    LowPower.attachInterruptWakeup(digitalPinToInterrupt(IR2SENSORPIN), IRInterrupt, FALLING);
  }


  // Setup button pin (button for wifi )
  pinMode(buttonPin, INPUT_PULLUP);
  // Attach an interrupt to wake up from low power on button push
  LowPower.attachInterruptWakeup(digitalPinToInterrupt(buttonPin), buttonInterrupt, FALLING);

  InitializeRFID();  // Initialize RFID reader and put in low power mode.
  digitalWrite(RFIDENABLEPIN, LOW);
  InitializeMemShield();  // initialize the memshield which has the SD card
                          // check the real time clock state
  if (RTClock) {
    InitializeRTC();
    DateTime now = rtc.now();
    lastYear = now.year();
    lastMonth = now.month();
    lastDay = now.day();
    SerialUSB.println("calling handleRTCfile from setup");
    handleRTCFileInitialization();
  }
  SerialUSB.println("going to extract last read period");
  // Extract last written Read Period from SD card and set it,  if no file id.txt exists create it.
  ReadPeriod = extractLastReadPeriod();
}

//  The main loop enables interrupts, gives a visiual indication of entering low power mode (using the built in LED on the MKR1010 board),
//  Enters low power mode and awaits an interrupt of either someone pushing the button or the break-beam being broken.
//  If the button was pushed, it moves to hanlde wifi connections ( transfer files, send any error messages)
//  If the breakbeam was broken, it turns on the RFID reader and trys to read any implanted RFID chips within range. It then writes any IDs to a file on the SD card.

void loop() {
  unsigned int countdownMS;

  if (RTClock && !RTCProblems) {
    Wire.begin();  // Need to do this each time we wake
    rtc.start();   
  }
  // each time through the loop set the breakbeam and button as interrupts
  InitializeIRBreakBeam();
  InitializeButton();
  

  // enable interrupts 
  interrupts();

  //visual indication in Low Power Mode - yellow buit-in LED is turned off.
  digitalWrite(LED_BUILTIN, LOW);
  if (RGBLed && !LedIsRed) {
    NoLight();
  }
  if (debug) {
    SerialUSB.println("Going to Sleep");
  }
  // Enter sleep mode
  LowPower.sleep();  //put processor in sleep mode until the breakbeam is broken or the wifi button is pushed.
  if (debug) {
    SerialUSB.println("Woke Up");
  }
  //reinitialize elements that need it when waking up from low power sleep
  if (RTClock && !RTCProblems) {
    Wire.begin();
    rtc.start();
    //check to see if the date has changed since we last woke up and create a new file if necessary
    // Continuously check if the date has changed
    DateTime now = rtc.now();

    // Check if the date has changed
    if (now.year() != lastYear || now.month() != lastMonth || now.day() != lastDay) {
      // Update the stored date
      lastYear = now.year();
      lastMonth = now.month();
      lastDay = now.day();

      // Update the filenames for the new date
      handleRTCFileInitialization();
    }
  }
  //visual indication the processor has woken up for debugging
  digitalWrite(LED_BUILTIN, HIGH);
  if (RGBLed) {
    GreenLight();  // temporary turn on green light (if it's not red) as visual indicator
  }

  // set up watchdog so it will reset the processor if the software hangs for any reason
  countdownMS = Watchdog.enable(BarkTime);

  if (debug) {
    SerialUSB.println("enabled the watchdog");
  }

  // check first if the button was pushed, and go to function to establish a WiFiconnection and tranfer data if so
  if (buttonPressed) {

    WakeUpWifiOnly();
    if (IsWiFi) {
      HandleWifiConnection();  // Function for connecting to another device to transfer data

    } else {
      if (debug) {
        SerialUSB.println("wifi didnt' start up something wrong with board");
      }
      if (RGBLed) {
        RedLight();  // Turn on the LED and make it RED so people know something is wrong
        if (debug) { SerialUSB.println("WiFiProblems"); }
      }
    }

    buttonPressed = false;  //Reset button flag
    Watchdog.reset();
    delay(2000);  // a delay to make sure the wifi buffer cleared before ending wifi.
    Watchdog.reset();
    Wifistatus = WL_IDLE_STATUS;  // reset the wifi status to idle

    WiFi.end();
    if (RGBLed) {  //  blue light needs to be turned off to indicate wifi no longer available, if it was red make it red otherwise make it green.
      if (LedIsRed) {
        RedLight();
      } else {
        GreenLight();
      }
    }
    irInterruptTriggered = false;
  }

  if (irInterruptTriggered) {
    //if there are SD Card problems there is no reason to turn on the RFID reader as nothing will be recorded
    // this will change if add code to use flash in case of SD Card issues.
    if (!SDCardProblems) {
      if (debug) { SerialUSB.println("IR beam interrupted"); }
      wakeupRFIDOnly();
      // increment the read period
      ReadPeriod++;
      // if we have a real time clock get the time
      //due to regular conflict between interrupts and RTC operation restart the I2C comms and communications
      if (RTClock && !RTCProblems) {
        Wire.begin();
        rtc.start();
      }
      if (RTClock && !RTCProblems) {
        IRInterruptTime = rtc.now();
      }
      readRFIDDevice();  //Try finding an RFID tag for the set read time
    }
    irInterruptTriggered = false;  //Reset IR flag
    
  }

  // This is a bit of test code to see if the watchdog is working
  if (TestWatchdog) {
    DoesTheDogHunt();
  }

  // always disable the watchdog before going to sleep again as the watchdog and sleep functions don't play together
  Watchdog.disable();
}
